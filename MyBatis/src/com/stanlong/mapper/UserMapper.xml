<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD//EN"
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 
注意：使用mapper代理方法开发，namespace有特殊重要的作用
-->
<mapper namespace="com.stanlong.e_mapper_proxy.UserDao">

	<!-- 定义sql片断
		id:sql片段唯一标识
		基于单表判断，这样sql片断的可重用性高，在sql版本中不要包含 where
	-->
	<sql id="query_user_where">
		<if test="userCustomer!=null">
			<if test="userCustomer.sex!=null"> and user.sex = #{userCustomer.sex} </if>
			<if test="userCustomer.username!=null"> AND user.username LIKE '%${userCustomer.username}%' </if>
		</if>
		<if test="ids!=null">
			<!--
				foreach:遍历传的id
				collection:输入对象中集合的属性
				item:每次遍历时生成的对象名
				open：开始遍历时的拼接串
				close：结束遍历时的拼接串
				separator：两个对象中的需要拼接的串
			 -->
			<!-- <foreach collection="ids" item="id" open="AND(" close=")" separator="OR">
				id = #{id}
			</foreach> -->
			<foreach collection="ids" item="id" open=" AND id IN(" close=")" separator="," >
				#{id}
			</foreach>
		</if>
	</sql>

	<!-- 定义resultMap
		type: resultMap 所映射的java对象，可以使用别名
		id: 对 resultMap 的唯一标识
	 -->
	<resultMap type="user" id="userResultMap">
		<!--
			id:表示查询结果的唯一标识
			column:查询出来的列名
			property:type指定的pojo类型中的属性名
			最终  resultMap 要将 column 和 property 进行映射
		 -->
		<id column="u_name" property="username"/>
		<!--
			result:对普通名称的映射
			column:查询出来的列名
			property:type指定的pojo类型中的属性名
			最终  resultMap 要将 column 和 property 进行映射
		-->
		<result column="u_sex" property="sex"/>
	</resultMap>

<!-- 多对多查询 -->
	<resultMap type="User" id="findUserAndItems">
		<!-- 用户信息 -->
		<id column="user_id" property="id"/>
		<result column="username" property="username"/>
		<result column="sex" property="sex"/>
		<result column="address" property="address"/>
		
		<!-- 订单信息 -->
		<collection property="ordersList" ofType="Orders">
			<id column="id" property="id"/>
			<result column="user_id" property="userId"/>
			<result column="number" property="number"/>
			<result column="createtime" property="createtime"/>
			<result column="note" property="note"/>
		<!-- 商品明细 -->
		<collection property="orderdetails" ofType="Orderdetail">
			<id column="orderdetail_id" property="id"/>
			<result column="items_id" property="itemsId"/>
			<result column="items_num" property="itemsNum"/>
			<result column="orders_id" property="ordersId"/>
			<!-- 商品 -->
			<association property="items" javaType="Items">
				<id column="items_id" property="id"/>
				<result column="items_name" property="name"/>
				<result column="items_detail" property="detail"/>
				<result column="items_price" property="price"/>
			</association>
		</collection>
		</collection>
	</resultMap>

	<!-- 在映射文件中配置sql语句 -->
	<!-- id:标识映射文件中的sql， 将sql语句封装到edStatement对象中， 所以将id称为 statement 的id
		parmterType:指定输入参数的类型，这里指定int型
		resultType:指定输出结果映射的java对象类型，select指定resultType表示将单条记录映射成java对象
		#{}表示一个占位符
		#{id} 其中id表示输入的参数，参数名称就是id,如果输入的参数类型是简单类型，#{}中的参数名称可以任意
	 -->
	<select id="findUserById" parameterType="int" resultType="user">
		SELECT * FROM user WHERE id = #{id}
	</select>
	
	<!-- 使用 resultMap进行输出映射 -->
	<select id="findUserByIdResultMap" parameterType="int" resultMap="userResultMap">
		SELECT id, username as u_name, sex AS u_sex FROM user WHERE id = #{id}
	</select>
	
	<!-- 根据用户名称模糊查询用户信息
		${}:表示拼接sql串， 将接收到的参数内容不加任何修饰拼接在sql中, 会引用sql注入
	 -->
	<select id="findUserByName" parameterType="java.lang.String" resultType="user">
		SELECT * FROM user WHERE username LIKE '%${_parameter}%'
	</select>
	
	<!-- 添加用户
		mybatis 通过 获取对象的属性值
	 -->
	<insert id="insertUser" parameterType="user">
		<!-- 将插入数据的主键返回到user对象中
			SELECT LAST_INSERT_ID(): 得到刚插入记录的主键值，只适用于自增长主键
			keyProperty：将查询到的主键值设置到 parameterType指定的对象的那个属性
			order: SELECT LAST_INSERT_ID() 相对于insert语句的执行顺序
			resultType:指定返回结果的类型
		-->
		<selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
			SELECT LAST_INSERT_ID()
		</selectKey>
		
		<!--
			使用非自增主键
			<selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String">
				SELECT uuid()
			</selectKey>
			插入记录
			INSERT INTO USER (id,username, sex, birthday, address) VALUES(#{id}, #{username},#{sex},#{birthday}, #{address})
		 -->
		
		INSERT INTO USER (username, sex, birthday, address) VALUES(#{username},#{sex},#{birthday}, #{address})
	</insert>
	
	<!-- 根据id删除用户 -->
	<delete id="deleteUserById" parameterType="int">
		DELETE FROM user WHERE id = #{id}
	</delete>
	
	<!-- 根据id更新用户 -->
	<update id="updateUserById" parameterType="user">
		UPDATE user SET username=#{username}, birthday=#{birthday}, sex = #{sex}, address=#{address} 
		WHERE id = #{id}
	</update>
	
	<!-- 用户信息综合查询 -->
	<!-- 动态拼接sql 
		where标签可以自动去掉第一个 and
	-->
	<select id="findUserList" parameterType="UserQueryVo" resultType="UserCustomer">
		SELECT * FROM user
		<where>
			<!-- 引用 sql片断的id -->
			<include refid="query_user_where"></include>
		</where>
	</select>
	
	<!-- 查询用户总数 -->
	<select id="findUserCount" parameterType="UserQueryVo" resultType="int">
		SELECT count(1) FROM user WHERE user.sex = #{userCustomer.sex} AND user.username LIKE '%${userCustomer.username}%'
	</select>
	
	
	
	<!-- 用户-商品(多对多查询) -->
	<select id="findUserAndItems" resultMap="findUserAndItems">
		SELECT 
			t1.*
			,t2.username
			,t2.sex
			,t2.address
			,t3.id			AS orderdetail_id
			,t3.items_id
			,t3.items_num
			,t3.orders_id
			,t4.name		AS items_name
			,t4.detail		AS items_detail
			,t4.price		AS items_price
		FROM orders t1, user t2, orderdetail t3, items t4
		WHERE t1.user_id = t2.id 
			AND t1.id = t3.orders_id
			AND t3.items_id = t4.id
	</select>
	
	
</mapper>