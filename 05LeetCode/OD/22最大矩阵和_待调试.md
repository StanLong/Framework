# 最大矩阵和

https://blog.csdn.net/angellover2017/article/details/119985058

给定一个二维整数矩阵，要在这个矩阵中选出一个子矩阵，使得这个子矩阵内所有的数字和尽量大，我们把这个子矩阵称为和最大矩阵，子矩阵的选取原则是原矩阵中一块连续的矩形区域，单独一行、单独一列、整个矩阵，都算子矩阵。

**输入：**

输入的第一行包含2个整数n,m(1<=n,m<=10),表示一个n行m列矩阵，下面有n行，每行m个整数，同一行中，每两个数字之间一个空格，最后一个数字后没有空格，所有数字的取值范围为[-1000,1000]

**输出：**

输出一行，一个数字，表示选出的和最大子矩阵内所有数字的和。

**样例：**

```
输入：
3 3
951 589 39 
-583 -710 473 
-229 501 -594
```

**输出**

```
1579
```

**解释：**

```java
最大子矩阵就是
951 589 39
求和得到1579
```

```java
package com.stanlong.leetcode;

import java.io.BufferedInputStream;
import java.util.Scanner;

public class LeetCode {
    public static void main(String[] args) {
        Scanner s=new Scanner(new BufferedInputStream(System.in));
        int m=s.nextInt();
        int n=s.nextInt();
        int[][] matrix=new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j]=s.nextInt();
            }
        }
        int ans=Integer.MIN_VALUE;
        for (int i = 0; i <m ; i++) {
            int[] dp=new int[n];
            for (int j = i; j < m; j++) {
                for (int k = 0; k < n; k++) {
                    dp[k]+=matrix[j][k];
                }
                int[] sum=new int[n];
                int min=0;
                for (int k = 0; k < n; k++) {
                    sum[k]+=dp[k];
                    if (k>0)sum[k]+=sum[k-1];
                    ans=Math.max(ans,sum[k]-min);
                    min=Math.min(min,sum[k]);
                }
            }

        }
        System.out.println(ans);
    }
}
```

