# 平衡二叉树(AVL)

## 引入

学习过了二叉查找树，想必大家有遇到一个问题。例如，将一个数组{1,2,3,4}依次插入树的时候，形成了图1的情况。有建立树与没建立树对于数据的增删改查已经没有了任何帮助，反而增添了维护的成本。而只有建立的树如图2，才能够最大地体现二叉树的优点。

![](.././doc/32.png)

在上述的例子中，图2就是一棵平衡二叉树。平衡二叉树是由前苏联的数学家Adelse-Velskil和Landis在1962年提出的高度平衡的二叉树，根据科学家的英文名也称为AVL树

## AVL的定义

它具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过1

**平衡因子**：左子树的高度减去右子树的高度。由平衡二叉树的定义可知，平衡因子的取值只可能为0,1,-1.分别对应着左右子树等高，左子树比较高，右子树比较高。

**最小不平衡子树：** 在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的，如下。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。

　在图7中。2结点（左子树树高[2]-右子树树高[4]）的绝对值=2。同理，3结点的平衡因子也为(0-2)=2.此时同时存在了两棵不平衡子树，而以3为根的树是最小的不平衡子树。我们只要将其以3为中心，将最小不平衡树向左旋转，即可得到平衡二叉树，如图8。

![](.././doc/33.png)

## 平衡二叉树实现原理

平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点时，先检查是否因插入而破坏了树的平衡性，若是，找出最小不平衡树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各节点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。

## 旋转操作

### LL型调整

由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。

![](.././doc/37.png)

LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。
![](.././doc/38.png)

### RR型调整

由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B逆时针旋转一样。

![](.././doc/39.png)

RR型调整的一般形式如下图4所示，表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：

- 将A的右孩子B提升为新的根结点；
- 将原来的根结点A降为B的左孩子
- 各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。

![](.././doc/40.png)

### LR型调整

由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。

![](.././doc/41.png)

LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。

![](.././doc/42.png)

### RL型调整

由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。

![](.././doc/43.png)

RL型调整的一般形式如下图8所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。

![](.././doc/44.png)

```java
package com.stanlong;

import lombok.NonNull;
import lombok.Setter;
import lombok.Getter;
import lombok.ToString;
import lombok.RequiredArgsConstructor;

/**
 * 平衡二叉树
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        // int[] arr = {45, 12, 53, 3, 37, 100, 24, 61, 90, 78};
        int[] arr = {45, 12, 53, 3, 37, 24};
        AVLTree avlTree = new AVLTree();
        for(int i=0; i<arr.length; i++){
            avlTree.add(new Node(arr[i]));
        }
        System.out.println("------中序遍历------");
        avlTree.infixOrder();

        // 树的高度
        System.out.println("树的高度: " + avlTree.getRoot().height());

        // 左子树的高度
        System.out.println("左子树的高度: " + avlTree.getRoot().leftHeight());

        // 右子树的高度
        System.out.println("右子树的高度: " + avlTree.getRoot().rightHeight());
    }
}

// Node 节点
@Setter
@Getter
@ToString(of={"value"})
@RequiredArgsConstructor
class Node{
    @NonNull
    private int value;
    private Node left;
    private Node right;

    /**
     * 用递归的方式添加节点
     * @param node 要添加的节点
     */
    public void add(Node node){
        if(node == null){
            return;
        }
        // 左子节点都比根节点小
        if(node.value < this.value){
            if(this.left == null){
                this.left = node;
            }else {
                this.left.add(node); // 递归往左子树添加
            }
        }
        // 右子节点都比根节点大, 如果值相同，将该子节点放在左右均可
        if(node.value >= this.value){
            if(this.right == null){
                this.right = node;
            }else {
                this.right.add(node);
            }
        }

        // 加入新的节点后，判断树是否平衡
        if(leftHeight() - rightHeight() >= 2){ // 左比右高， 进行右旋转
            rightRotate();
        }
        if(leftHeight() - rightHeight() <= -2) { // 右比左高，进行左旋转

        }
    }

    // 中序遍历
    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    // 查找节点
    public Node search(int value){
        if(value == this.value){ // 找到
            return this;
        }else if(value < this.value){ // 往左子树递归
            if(this.left != null){
                return this.left.search(value);
            }
        }else{ // 往右子树递归
            if(this.right != null){
                return this.right.search(value);
            }
        }
        return null;
    }

    // 查找父节点
    public Node searchParent(int value){
        if((this.left != null && this.left.value == value) ||
                (this.right != null && this.right.value == value)){ // 当前节点就是要删除节点的父节点
            return this;
        }else { //
            if(value < this.value && this.left != null){ // 向左子树递归
                return this.left.searchParent(value);
            }else if(value >= this.value && this.right != null){ // 向右子树递归
                return this.right.searchParent(value);
            }
        }
        return null;
    }

    /**
     * 返回当前节点为根节点时树的高度
     * @return 树的高度
     */
    public int height(){
        return Math.max(left == null ? 0: left.height(), right == null?0:right.height()) + 1;
    }

    /**
     * 左子树的高度
     * @return 左子树的高度
     */
    public int leftHeight(){
        if(left == null){
            return 0;
        }
        return left.height();
    }

    /**
     * 右子树的高度
     * @return 右子树的高度
     */
    public int rightHeight(){
        if(right == null){
            return 0;
        }
        return right.height();
    }

    /**
     * 右旋转
     */
    public void rightRotate(){
        // 1. 创建一个新的节点，值等于当前节点的值
        Node newRight = new Node(value);

        // 2. 把新节点的右子树，设置为当前节点的右子树
        newRight.right = right;

        // 3. 把新节点的左子树设置为当前节点左子树的右子树
        newRight.left = left.right;

        // 4. 把当前节点的值换为左子节点的值
        value = left.value;

        // 5. 把当前节点的左子树设置为左子树的左子树
        left = left.left;

        // 6. 把当且节点的右子树设置为新节点
        right = newRight;

    }

    /**
     * 左旋转
     */
    public void leftRotate(){

    }

}

/**
 * 平衡二叉树
 */
class AVLTree{
    @Getter
    private Node root;

    public void add(Node node){
        if(root == null){
            root = node;
        }else {
            root.add(node);
        }
    }

    public void infixOrder(){
        if(root != null){
            root.infixOrder();
        }else {
            System.out.println("树为空！");
        }
    }

    public Node search(int value){
        if(root == null){
            return null;
        }else {
            return root.search(value);
        }
    }

    public Node searchParent(int value){
        if(root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    public void delNode(int value){
        if(root == null){
            return;
        }else {
            Node target = search(value); // 查找要删除的节点
            if(target == null){
                return;
            }
            // 如果该二叉树只有一个节点，那删除之后就是一个空树了
            if(root.getLeft() == null && root.getRight() == null && root.getValue() == value){
                root = null;
                return;
            }

            // 查找该节点的父节点
            Node parent = searchParent(value);

            // 1. 如果要删除的节点是叶子节点, 则直接删除该节点
            if(target.getLeft() == null && target.getRight() == null){
                if(parent.getLeft() != null && parent.getLeft().getValue() == value){ // 要删除的节点是左子节点
                    parent.setLeft(null);
                }else if(parent.getRight() != null && parent.getRight().getValue() == value) { // 要删除的是右子节点
                    parent.setRight(null);
                }
            } else if(target.getLeft() != null && target.getRight() != null){// 3.被删除的节点既有左子树，也有右子树
                int minValue = delRightMin(target.getRight()); // 删除并返回右子树节点的最小值
                target.setValue(minValue);  // 用右子树的最小值替换要删除的节点
            }else { // 2. 被删除的节点只有左子树或者只有右子树，用其左子树或者右子树替换该节点
                // 要删除的节点只有左子树
                if(target.getLeft() != null){
                    if(parent.getLeft() != null && parent.getLeft().getValue() == value){ //要删除的节点是父节点左子节点
                        parent.setLeft(target.getLeft());
                    }else { // 要删除的节点是父节点的右子节点
                        parent.setRight(target.getLeft());
                    }
                }else { // 要删除的节点有右子树
                    if(parent.getRight() != null && parent.getRight().getValue() == value){ //要删除的节点是父节点左子节点
                        parent.setRight(target.getRight());
                    }else { // 要删除的节点是父节点的右子节点
                        parent.setLeft(target.getRight());
                    }

                }
            }
        }
    }

    /**
     * 返回右子树最小值的节点，并删除该节点
     * @param node 要删除节点的右子树的第一个节点
     * @return 以node为根节点的二叉排序树的右子树最小值
     */
    public int delRightMin(Node node){
        Node target = node;
        while(target.getLeft() != null){
            target = target.getLeft();
        }
        delNode(target.getValue());
        return target.getValue();
    }
}
```

## 学习

```java
import java.util.LinkedList;
import java.util.Queue;

/**
 * @author wuyou
 */
public class AVLTreeDemo extends BinarySortTreeDemo{
    private Node root;
    private final int LEFT = 1;
    private final int RIGHT = -1;
    private final int MAX_LEFT = 2;
    private final int MAX_RIGHT = -2;

    public static void main(String[] args) {
        AVLTreeDemo bbt = new AVLTreeDemo();
        bbt.put(3);
        bbt.put(2);
        bbt.put(1);
        bbt.put(4);
        bbt.put(5);
        bbt.put(6);
        bbt.put(7);
        bbt.put(10);
        bbt.put(9);
        bbt.midOrderErgodic();
        System.out.println();
        System.out.println("-----各节点平衡状况-----");
        bbt.sequenceErgodic();
        System.out.println();

        bbt.delete(5);
        bbt.delete(2);
        bbt.midOrderErgodic();
        System.out.println();
        System.out.println("-----各节点平衡状况-----");
        bbt.sequenceErgodic();
        System.out.println();
    }

    /**
     * 插入节点
     * @param weight
     */
    public void put(int weight) {
        putData(root, weight);
    }

    private boolean putData(Node node, int weight) {
        if(node == null) {
            node  = new Node(null, weight);
            root = node;
            return true;
        }
        int t;
        Node tempBefore;
        Node temp = node;
        do {
            tempBefore = temp;
            t = (int) (temp.weight - weight);
            if(t < 0) {
                temp = temp.rightChild;
            }
            else if(t > 0) {
                temp = temp.leftChild;
            }
            else {
                // 说明是已经包含相同值，不允许插入
                return false;
            }
        } while(temp != null);
        Node newNode = new Node(tempBefore, null, weight);
        if(t < 0) {
            tempBefore.rightChild = newNode;
        }
        else if(t > 0) {
            tempBefore.leftChild = newNode;
        }
        rebuild(tempBefore);
        return true;

    }

    /**
     * 平衡二叉树的方法
     * @param node
     */
    public void rebuild(Node node) {
        // 向parent循环判断是否需要需要旋转
        while(node != null) {
            if(calcNodeBalanceValue(node) == MAX_LEFT) {
                fixAfterInsertion(node, LEFT);
            }
            else if(calcNodeBalanceValue(node) == MAX_RIGHT) {
                fixAfterInsertion(node, RIGHT);
            }
            node = node.parent;
        }
    }

    /**
     * 调整树的结构
     * @param node
     * @param type
     */
    public void fixAfterInsertion(Node node, int type) {
        if(type == LEFT) {
            Node leftChild = node.leftChild;
            // 右旋
            if(leftChild.leftChild != null) {
                rightRotation(node);
            }
            // 左右旋
            else if(leftChild.rightChild != null) {
                leftRotation(leftChild);
                rightRotation(node);
            }
        }
        else if(type == RIGHT) {
            Node rightChild = node.rightChild;
            // 左旋
            if(rightChild.rightChild != null) {
                leftRotation(node);
            }
            // 右左旋
            else if(rightChild.leftChild != null) {
                rightRotation(rightChild);
                leftRotation(node);
            }
        }
    }

    public Node rightRotation(Node node) {
        if (node != null) {
            Node leftChild = node.leftChild;
            node.leftChild = leftChild.rightChild;
            // 如果leftChild的右节点存在，则需要将该右节点的父节点指定给node节点
            if (leftChild.rightChild != null) {
                leftChild.rightChild.parent = node;
            }
            leftChild.parent = node.parent;
            if (node.parent == null) {
                this.root = leftChild;
            }
            // 即node节点在它原父节点的右子树中
            else if (node.parent.rightChild == node) {
                node.parent.rightChild = leftChild;
            }
            else if (node.parent.leftChild == node) {
                node.parent.leftChild = leftChild;
            }
            leftChild.rightChild = node;
            node.parent = leftChild;
            return leftChild;
        }
        return null;
    }

    public Node leftRotation(Node node) {
        if (node != null) {
            Node rightChild = node.rightChild;
            node.rightChild = rightChild.leftChild;
            if (rightChild.leftChild != null) {
                rightChild.leftChild.parent = node;
            }
            rightChild.parent = node.parent;
            if(node.parent == null) {
                this.root = rightChild;
            }
            else if(node.parent.rightChild == node) {
                node.parent.rightChild = rightChild;
            }
            else if(node.parent.leftChild == node) {
                node.parent.leftChild = rightChild;
            }
            rightChild.leftChild = node;
            node.parent = rightChild;
            return rightChild;
        }
        return null;
    }

    /**
     * 计算node节点的BF值
     * @param node
     * @return
     */
    public int calcNodeBalanceValue(Node node) {
        if(node != null) {
            return getHeightByNode(node);
        }
        return 0;
    }

    private int getHeightByNode(Node node) {
        return getChildDepth(node.leftChild) - getChildDepth(node.rightChild);
    }

    private int getChildDepth(Node node) {
        if(node == null) {
            return 0;
        }
        return 1 + Math.max(getChildDepth(node.leftChild), getChildDepth(node.rightChild));
    }

    /**
     * 删除指定val值的节点
     * @param val
     * @return
     */
    public boolean delete(int val) {
        Node node = getNode(val);
        if(node == null) {
            return false;
        }
        boolean flag = false;
        Node p = null;
        Node parent = node.parent;
        Node leftChild = node.leftChild;
        Node rightChild = node.rightChild;
        if(leftChild == null && rightChild == null) {
            if(parent != null) {
                if(parent.leftChild == node) {
                    parent.leftChild = null;
                }
                else if(parent.rightChild == node) {
                    parent.rightChild = null;
                }
            }
            else {
                this.root = null;
            }

            p = parent;
            node = null;
            flag = true;
        }
        else if(leftChild == null && rightChild != null) {
            if(parent != null && parent.weight > val) {
                parent.leftChild = rightChild;
            }
            else if(parent != null && parent.weight < val) {
                parent.rightChild = rightChild;
            }
            else {
                this.root = rightChild;
            }
            p = parent;
            node = null;
            flag = true;
        }
        else if(leftChild != null && rightChild == null) {
            if(parent != null &&  parent.weight > val) {
                parent.leftChild = leftChild;
            }
            else if(parent != null && parent.weight < val) {
                parent.rightChild = leftChild;
            }
            else {
                this.root = leftChild;
            }

            p = parent;
            node = null;
            flag = true;
        }
        else if(leftChild != null && rightChild != null) {
            Node successor = getSuccessor(node);
            int tempData = (int) successor.weight;
            if(delete(tempData)) {
                node.data = tempData;
            }
            p = successor;
            successor = null;
            flag = true;
        }

        if(flag) {
            this.rebuild(p);
        }
        return true;
    }


    /**
     * 获得指定节点
     * @param key
     * @return
     */
    public Node getNode(int key) {

        Node node = root;
        int t;
        do {
            t = (int) (node.weight - key);
            if(t > 0) {
                node = node.leftChild;
            }
            else if(t < 0) {
                node = node.rightChild;
            }
            else {
                return node;
            }
        } while(node != null);
        return null;
    }

    /**
     * 获得指定节点的后继
     * 找到node节点的后继节点
     * 1、先判断该节点有没有右子树，如果有，则从右节点的左子树中寻找后继节点，没有则进行下一步
     * 2、查找该节点的父节点，若该父节点的右节点等于该节点，则继续寻找父节点，
     *   直至父节点为Null或找到不等于该节点的右节点。
     * 理由，后继节点一定比该节点大，若存在右子树，则后继节点一定存在右子树中，这是第一步的理由
     *      若不存在右子树，则也可能存在该节点的某个祖父节点(即该节点的父节点，或更上层父节点)的右子树中，
     *      对其迭代查找，若有，则返回该节点，没有则返回null
     * @param node
     * @return
     */
    public Node getSuccessor(Node node) {
        if(node.rightChild != null) {
            Node rightChild=  node.rightChild;
            while(rightChild.leftChild != null) {
                rightChild = rightChild.leftChild;
            }
            return rightChild;
        }
        Node parent = node.parent;
        while(parent != null && (node == parent.rightChild)) {
            node = parent;
            parent = parent.parent;
        }
        return parent;
    }

    /**
     * 中序遍历
     */
    public void midOrderErgodic() {
        this.midOrderErgodic(this.root);
    }

    private void midOrderErgodic(Node node) {
        if(node != null) {
            this.midOrderErgodic(node.leftChild);
            System.out.print(node.weight + ", ");
            this.midOrderErgodic(node.rightChild);
        }
    }

    /**
     * 层序遍历
     */
    public void sequenceErgodic() {
        if(this.root == null) {
            return;
        }
        Queue<Node> queue = new LinkedList<>();
        Node temp = null;
        queue.add(this.root);
        while(!queue.isEmpty()) {
            temp = queue.poll();
            System.out.println("当前节点值：" + temp.weight + ", 左子树深度：" + getChildDepth(temp.leftChild) + ", 右子树深度：" + getChildDepth(temp.rightChild) + ", BF：" + calcNodeBalanceValue(temp));
            if(temp.leftChild != null) {
                queue.add(temp.leftChild);
            }
            if(temp.rightChild != null) {
                queue.add(temp.rightChild);
            }
        }
    }
}
```

