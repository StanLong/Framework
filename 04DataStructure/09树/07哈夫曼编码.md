# 哈夫曼编码

哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。

**哈夫曼编码，主要目的是根据使用频率来最大化节省字符（编码）的存储空间**

## 哈夫曼编码的生成过程

假如一段信息里只有A，B，C，D，E，F这6个字符，他们出现的次数依次是2次，3次，7次，9次，18次，25次，如何设计对应的编码呢？

我们不妨把这6个字符当做6个叶子结点，把字符出现次数当做结点的权重，以此来生成一颗哈夫曼树：

![](.././doc/28.png)

哈夫曼树的每一个结点包括左、右两个分支，二进制的每一位有0、1两种状态，我们可以把这两者对应起来，结点的左分支当做0，结点的右分支当做1，如下图

![](.././doc/29.png)

这样一来，从哈夫曼树的根结点到每一个叶子结点的路径，都可以等价为一段二进制编码：

![](.././doc/30.png)

上述过程借助哈夫曼树所生成的二进制编码，就是哈夫曼编码。

```java
package com.stanlong;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * 哈夫曼编码
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        // 要编码的字符串
        String content = "AABBBCCCCCCCDDDDDDDDDEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFFFFFF";
        // 将要编码的字符串转化成Byte数组
        byte[] contentBytes = content.getBytes();
        System.out.println(Arrays.toString(contentBytes));
        getNode(contentBytes);

    }

    public static void getNode(byte[] bytes){
        ArrayList<Node> nodeList = new ArrayList<>();

        // 遍历bytes， 统计每一个byte出现的次数
        Map<Byte, Integer> map = new HashMap<>();
        int value=0;
        for(byte key : bytes){
            value = map.getOrDefault(key, 0);
            value = value + 1;
            map.put(key, value);
        }
        System.out.println(map);
    }
}

/**
 * 节点带权值
 */
//
@RequiredArgsConstructor
@ToString(of={"value", "weight"})
class Node implements Comparable<Node>{
    @NonNull
    private byte value; // 存放数据, byte的取值范围是-128到+127
    @NonNull
    private int weight; // 存放数据的权值，表示数据出现的次数
    private Node left;
    private Node right;

    @Override
    public int compareTo(Node node) {
        return this.weight - node.weight;
    }

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }
}
```

