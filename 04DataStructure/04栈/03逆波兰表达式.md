# 逆波兰表达式

中缀表达式转逆波兰表达式

操作步骤：

1. 初始化两个栈：运算符栈 s1 和 储存中间结果的栈 s2

2. 从左至右扫描中缀表达式

3. 遇到操作数时，将其压入 s2

4. 遇到操作符时，比较其与 s1 栈顶运算符的优先级：

   4.1 如果 s1 为空，或者栈顶元素是  "(" ，则直接将运算符入栈

   4.2 如果该操作符的优先级比 s1 栈顶操作符的优先级高， 也将运算符压入 s1

   ​     由4.1和4.2可推导 "("  的优先级最低。

   4.3 否则将 s1 栈顶的操作符弹出并压入到 s2 中。 再次重复 4.1-4.3

5. 遇到括号时

   5.1 如果是左括号 "(" , 则直接压入 s1

   5.2 如果是右括号 ")" , 则依次弹出 s1 栈顶的运算符，并压入 s2, 直到遇到左括号"(" 为止。此时将这一对括号丢弃

6. 重复步骤2至步骤5， 直到表达式的最右边

7. 将 s1 中剩余的运算符依次弹出并压入 s2

8. 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

## Java版

```java
package com.stanlong;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * 逆波兰表达式（后缀表达式）
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        String expression = "1+((2+3)*4)-5";
        List<String> list = toInfixExpressionList(expression); // 将中缀表达式拆成一个列表

        List<String> parseSuffixExpression = parseSuffixExpressionList(list); // 将中缀表达式转成后缀表达式

        System.out.println(parseSuffixExpression);

        int result = calculate(parseSuffixExpression); // 计算后缀表达式
        System.out.println(result);


    }

    // 将中缀表达式转成list
    // Infix:中缀
    public static List<String> toInfixExpressionList(String s){
        List<String> ls = new ArrayList<>();
        int i = 0; // 帮助遍历中缀表达式
        String str=""; // 拼接多位数
        char c=' '; // 遍历中缀表达式取出的字符
        do{
            if((c=s.charAt(i))<48 || (c=s.charAt(i))>57){ // 如果扫描到的是非数字
                ls.add("" + c);
                i++;
            }else{
                while (i<s.length() && (c=s.charAt(i))>=48 && (c=s.charAt(i))<=57){
                    str = str+c;
                    i++;
                }
                ls.add(str);
                str="";
            }
        }while (i<s.length());
        return ls;
    }

    // 将中缀表达式的 list 转成后缀表达式对应的 list
    public static List<String> parseSuffixExpressionList(List<String> list){
        // 定义符号栈
        Stack<String> stack = new Stack<>();

        // 定义一个 List 用来保存中间结果
        List<String> middleResult = new ArrayList<>();

        for(String item: list){
            if(item.matches("\\d+")){
                middleResult.add(item);
            }else if(item.equals("(")){
                stack.push(item);
            }else if(item.equals(")")){
                while (!stack.peek().equals("(")){
                    middleResult.add(stack.pop());
                }
                stack.pop();
            }else{
                while (stack.size() != 0 && Operation.getValue(stack.peek()) >= Operation.getValue(item)){
                    middleResult.add(stack.pop());
                }
                stack.push(item);
            }
        }

        while (stack.size()!=0){
            middleResult.add(stack.pop());
        }
        return middleResult;
    }

    /**
     * 计算后缀表达式
     *
     * 思路：
     * 遍历后缀表达式
     * 如果是数字，就将数字入栈
     * 如果是操作符，则弹出栈中的数字进行运算，然后再将运算结果入栈
     */
    public static int calculate(List<String> list){
        Stack<String> stack = new Stack<>();
        for(String item: list){
            if(item.matches("\\d+")){
                stack.push(item);
            }else{
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int result = 0;
                if(item.equals("+")){
                    result = num1 + num2;
                }else if(item.equals("-")){
                    result = num2 - num1;
                }else if(item.equals("*")){
                    result = num1 * num2;
                }else if(item.equals("/")){
                    result = num2 / num1;
                }else{
                    throw new RuntimeException("错误的操作符");
                }
                stack.push("" + result);
            }
        }
        return Integer.parseInt(stack.pop());
    }
}

// 定义操作符优先级
class Operation{
    private static int ADD=1;
    private static int SUB=1;
    private static int MUL=2;
    private static int DIV=2;

    public static int getValue(String operation){
        int result = 0;
        switch (operation){
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                result = 0;
                break;
        }
        return result;
    }
}
```

