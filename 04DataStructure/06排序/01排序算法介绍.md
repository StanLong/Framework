# 排序算法介绍

排序也称排序算法 (Sort Algorithm)，排序是将一 组数据，依指定的顺序进行排列 的过程。

## 排序的分类

- 内部排序: 指将需要处理的所有数据都加载 到内部存储器中进行排序。
- 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

## 常见的排序算法分类

![](.././doc/06.png)

## 算法的时间复杂度

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用$T(n)$表示，若有某个辅助函数$f(n)$，使得当$n$ 趋近于无穷大时，$T(n) / f(n)$ 的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作 $T(n)=Ｏ( f(n) )$，称$Ｏ( f(n) )$ 为算法的渐进时间复杂度，简称时间复杂度。
2. $T(n)$ 不同，但时间复杂度可能相同。 如：$T(n)=n²+7n+6$ 与 $ T(n)=3n²+2n+2 $ 它们的T(n) 不同，但时间复杂度相同，都为$O(n²)$。
3. 计算时间复杂度的方法：
   - 用常数1代替运行时间中的所有加法常数 $ T(n)=n²+7n+6 => T(n)=n²+7n+1$
   - 修改后的运行次数函数中，只保留最高阶项 $ T(n)=n²+7n+1 => T(n) = n²$ 
   - 去除最高阶项的系数 $ T(n) = n² => T(n) = n² => O(n²)$ 

## 常见的时间复杂度

| 复杂度     | 数学式               |
| ---------- | -------------------- |
| 常数阶     | O(1)                 |
| 对数阶     | O(log<sub>2</sub>n)  |
| 线性阶     | O(n)                 |
| 线性对数阶 | O(nlog<sub>2</sub>n) |
| 平方阶     | O(n<sup>2</sup>)     |
| 立方阶     | O(n<sup>3</sup>)     |
| k次方阶    | O(n<sup>k</sup>)     |
| 指数阶     | O(2<sup>n</sup>)     |

说明：常见的算法时间复杂度由小到大依次为：

Ο(1)＜O(log<sub>2</sub>n)＜Ο(n)＜O(nlog<sub>2</sub>n)＜O(n<sup>2</sup>)＜O(n<sup>3</sup>)＜O(n<sup>k</sup>) ＜O(2<sup>n</sup>) 

随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

### 常数阶O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

### 对数阶O(log<sub>2</sub>n)

```java
int i = 1;
while(i<n){
    i = i * 2
}
```

说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log<sub>2</sub>n也就是说当循环log<sub>2</sub>n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log<sub>2</sub>n)  。 O(log<sub>2</sub>n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log<sub>3</sub>n) .

### 线性阶O(n)

```java
for(i=1; i<=n;++i){
    j = i;
    j++;
}
```

说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

