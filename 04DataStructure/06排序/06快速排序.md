# 快速排序

![](.././doc/12.gif)

快速排序（Quicksort）是对冒泡排序的一种改进。具体算法描述如下：

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

## Java版

```java
package com.stanlong;

import java.util.Arrays;

/**
 * 快速排序
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        int[] arr = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
        quickSort(arr, 0, arr.length -1);
        System.out.println(Arrays.toString(arr));

    }

    /**
     * 快速排序
     * @param arr 待排序数组
     * @param left 待排序数组左索引
     * @param right 待排序数组右索引
     */
    public static void quickSort(int[] arr, int left, int right){

        if(left >= right){
            return;
        }

        // i, j 用于左右滑动
        int i = left;
        int j = right;
        
        // 基准值， 可任意定制。这里以左边第一个元素为基准
        int key = arr[i];

        while (i<j){
            // 把 i 作为基准。 i 不动, j 从右往左滑. 一直滑动到 arr[j] 小于 key
            while (arr[j] >= key && i<j){
                j--;
            }

            // 小于基准值的放到基准值右边
            int t=0;
            t = arr[j];
            arr[j] =arr[i];
            arr[i] = t;

            while (arr[i] <= key && i<j){
                i++;
            }

            // 大于基准值的放到基准值左边
            t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }

        // 迭代左区间
        quickSort(arr, left, i-1);

        // 迭代右区间
        quickSort(arr, i+1, right);
    }
}
```

