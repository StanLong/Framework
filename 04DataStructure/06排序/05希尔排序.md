# 希尔排序

![](.././doc/10.gif)

希尔排序的基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用插入排序算法排序；随着增量逐渐减少，每组包含的已排序数据越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

## Java版

```java
package com.stanlong;

import java.util.Arrays;

/**
 * 希尔排序
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        int[] arr = {84, 83, 88, 87, 61, 50, 70, 60, 80, 99};

        // 数据交换法

        // 交换用临时变量
        //int temp =0;

        // 统计比较循环次数
        //int count = 0;
//        for(int step = arr.length / 2; step > 0; step = step/2){
//            count = count + 1;
//            for(int i=step; i< arr.length; i++){
//                // 按步长step遍历各组的数据，每组数据有2个元素
//                // 已第一轮遍历为例，就是下标为0的数据和下标为step的数据比较
//                // 第二轮遍历就是下标为1和下标为step+1的数据比较
//                for(int j = i-step; j>=0; j=j-step){
//                    if(arr[j] > arr[j+step]){ // 交换数据
//                        temp = arr[j];
//                        arr[j] = arr[j+step];
//                        arr[j+step] = temp;
//                    }
//                }
//            }
//            System.out.println("第" + count + "轮排序结果: " + Arrays.toString(arr));
//        }
//        System.out.println("最终排序结果: " + Arrays.toString(arr));


        // 数据移动法
        // 统计比较循环次数
        int count = 0;
        for(int step = arr.length / 2; step > 0; step = step / 2){
            count = count + 1;
            for(int i = step; i< arr.length; i++){
                int j = i;
                int temp = arr[j];
                if(arr[j] < arr[j-step]){
                    while (j - step >=0 && temp < arr[j-step]){
                        // 移动
                        arr[j] = arr[j-step];
                        j = j-step;
                    }
                    arr[j] = temp;
                }
            }
            System.out.println("第" + count + "轮排序结果: " + Arrays.toString(arr));
        }
        System.out.println("最终排序结果: " + Arrays.toString(arr));
    }
}
```

```
第1轮排序结果: [50, 70, 60, 80, 61, 84, 83, 88, 87, 99]
第2轮排序结果: [50, 70, 60, 80, 61, 84, 83, 88, 87, 99]
第3轮排序结果: [50, 60, 61, 70, 80, 83, 84, 87, 88, 99]
最终排序结果: [50, 60, 61, 70, 80, 83, 84, 87, 88, 99]
```

