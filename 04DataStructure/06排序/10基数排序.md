# 基数排序

https://blog.csdn.net/bjweimengshu/article/details/102908292

![](.././doc/14.gif)

基本思想: 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零（如果是对字母排序就需要在后面补0了）。然后把排序工作拆分成多个阶段，每一个阶段只根据一个字符进行计数排序，一共排序k轮(k数位的最大值)。

基数排序既可以从高位优先进行排序（Most Significant Digit first，简称**MSD**），也可以从低位优先进行排序（Least Significant Digit first，简称**LSD**）

## Java版

### 字符串排序

```java
package com.stanlong;

import java.util.Arrays;

/**
 * 基数排序
 * 对字符串进行排序
 * 这里用的是 低位优先
 */
public class DataStructure {

    // ASCII 码是一套基于拉丁字母的字符编码，共收录了 128 个字符
    public static final int ASCII_RANGE = 128;

    public static void main(String[] args) throws Exception {
        String[] array = {"qd","abc","az","qwe", "hhh", "a", "cws", "ope"};
        String[] result = radixSort(array);
        System.out.println(Arrays.toString(result));
    }

    /**
     * 基数排序
     * @param array 待排序数组
     */
    public static String[] radixSort(String[] array){
        // 用于保存排序结果
        String[] result = new String[array.length];
        // 获取 array 中的最长数位值
        int maxLength = getLength(array);

        for(int k=maxLength-1; k>=0; k--){
            // 1. 创建辅助排序的统计数组
            int[] count = new int[ASCII_RANGE]; // 对字符排序，计数数组大小位128位就够用了
            for(int i=0; i< array.length;i++){
                int index = getCharIndex(array[i], k);
                count[index]++;
            }

            // 2. 统计数组变形， 后面元素的值等于前面元素值的和
            for(int i=1; i < count.length; i++){
                count[i] = count[i] + count[i-1];
            }

            // 3. 倒序遍历（倒序遍历是计数数组的稳定版本）原始数组
            for(int i=array.length-1; i>=0; i--){
                int index = getCharIndex(array[i], k);
                result[count[index] - 1] = array[i];
                count[index]--;
            }
            array = result.clone();
        }
        return array;

    }

    /**
     * 获取字符串第K位字符所对应的 ascii码 序号
     * @param str 待排序数组的第i个字符串
     * @param k 字符串的第k个字符
     * @return
     */
    private static int getCharIndex(String str, int k){
        if(str.length() < k+1){
            return 0;
        }
        return str.charAt(k);
    }

    // 获取 array 中的最长数位值
    private static int getLength(String[] array){
        int max = Integer.MIN_VALUE;
        for(String data : array){
            int strLen = data.length();
            max = Math.max(max, strLen);
        }
        return max;
    }
}
```

### 数值排序

```java
package com.stanlong;

import java.util.Arrays;

/**
 * 基数排序
 * 对手机号进行排序
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
        int[] result = radixSort(array);
        System.out.println(Arrays.toString(result));
    }

    /**
     * 基数排序
     * @param array 待排序数组
     */
    public static int[] radixSort(int[] array){

        // 用于保存排序结果
        int[] result = new int[array.length];

        // 声明计数数组，长度最多10
        int[] count = new int[10];

        // 获取 array 中的最长数位值
        int maxLength = getLength(array);

        for(int i=0; i<maxLength; i++){
            int division = (int)Math.pow(10, i); // 返回 10 的 i 次方, 用于处理个位，十位，百位
            for(int j=0; j< array.length;j++){
                int num = array[j] / division % 10;
                // 解释下这一行 假设 array[j] = 123
                // division 为 1 时，123 / 1 % 10 = 3 个位数
                // division 为 10 时， 123 / 10 % 10 = 2 十位数
                // division 为 100 时， 123 / 100 % 10 = 1 百位数
                count[num]++;
            }
            // 对 count 数组进行变形
            for(int m=1; m< count.length; m++){
                count[m] = count[m]+count[m-1];
            }

            // 倒序遍历array， 开始排序
            for(int n=array.length-1; n>=0; n--){
                int num = array[n] / division % 10;
                count[num]--;
                result[count[num]] = array[n];
            }

            /**
             * arraycopy
             *  src：要复制的数组(源数组)
             *  srcPos：复制源数组的起始位置
             *  dest：目标数组
             *  destPos：目标数组的下标位置
             *  length：要复制的长度
             */
            // result 数组从0开始复制array.length个值到array数组中从0开始的位置
            // 这一步是保存每一轮的排序结果
            System.arraycopy(result, 0, array, 0, array.length);

            // 每一轮排序结束后，计数数组置0
            Arrays.fill(count, 0);
        }
        return result;
    }

    // 获取 array 中的最长数位值
    private static int getLength(int[] array){
        int max = Integer.MIN_VALUE;
        for(int data : array){
            int strLen = (data+"").length();
            max = Math.max(max, strLen);
        }
        return max;
    }
}
```

## Scala版

### 字符串排序

### 数值排序

## Python版

### 字符串排序

### 数值排序

## 



