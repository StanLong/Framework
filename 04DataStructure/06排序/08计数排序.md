# 计数排序

https://www.cnblogs.com/xiaochuan94/p/11198610.html

## Java

### 基础版

```java
package com.stanlong;


import java.util.Arrays;

/**
 * 计数排序：
 * 主要思想：数学上的转化思想，将待排序数组的值转化成计数数组的索引，因为数组的索引是有序递增的。 最后将计数数组的索引遍历打印出来即可
 *      待排序数组 array
 *      计数数组 count
 *      结果数组 result
 *      转化方式：
 *          array 的值 为 count 的索引
 *          array 的值的个数 为 count 的值
 *      result 中保存 count 中值不为0的索引。
 *      注意：array 中的最大值如果特别大，那 count 的索引数也会很大，这是count会占用比较大的内存空间
 * 基础版：
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
        int[] result = countSort(array);
        System.out.println(Arrays.toString(result));
    }

    /**
     * 计数排序
     * @param array 待排序数组
     */
    public static int[] countSort(int array[]){
        // 1. 获取原数组中最大的值
        int max = Integer.MIN_VALUE;
        for(int data : array){
            max = Math.max(max, data);
        }

        // 2. 初始化计数数组
        int[] count = new int[max+1];

        // 3. 将原数组的值转化到计数数组中
        // array 的值 为 count 的索引
        // array 的值的个数 为 count 的值
        for(int data : array){
            count[data]++ ;
        }

        // 4. 创建结果数组
        int[] result = new int[array.length];

        // 结果数组索引
        int index = 0;

        // 5. 将计数数组中值不为0的索引保存到结果数组中
        for(int i=0; i< count.length; i++){
            while (count[i] != 0){
                result[index] = i;
                index++;
                count[i]--;
            }
        }
        return result;
    }
}
```

### 优化版

```java
package com.stanlong;


import java.util.Arrays;

/**
 * 优化版：
 *      找出 array 中的最小值，这样以原数组中最大值与最小值的差值作为计数数组的长度。计数数组就不需要开辟多余的空间了
 *      这时以原数组中每个值与最小值的差值作为计数数组的索引。最后保存到结果数组时，计数数组的每个索引再加上最小值。
 *
 * 优化版主要解决基础版空间浪费的问题
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
        int[] result = countSort(array);
        System.out.println(Arrays.toString(result));
    }

    /**
     * 计数排序
     * @param array 待排序数组
     */
    public static int[] countSort(int array[]){
        // 1. 获取原数组中最大的值
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for(int data : array){
            max = Math.max(max, data);
            min = Math.min(min, data);
        }

        // 2. 初始化计数数组, 这时计数数组就不需要开辟无效空间了
        int[] count = new int[(max-min)+1];

        // 3. 将原数组的值转化到计数数组中
        // array 的值与最小值的差值 为 count 的索引
        // array 的值与最小值差值的个数 为 count 的值
        for(int data : array){
            count[data-min]++ ;
        }

        // 4. 创建结果数组
        int[] result = new int[array.length];

        // 结果数组索引
        int index = 0;

        // 5. 将计数数组中值不为0的索引保存到结果数组中
        for(int i=0; i< count.length; i++){
            while (count[i] != 0){
                result[index] = i + min; // 补上减去的 min
                index++;
                count[i]--;
            }
        }
        return result;
    }
}
```

### 进阶版

```java
package com.stanlong;

import java.util.Arrays;

/**
 * 进阶版：
 *      观察发现：计数数组中 count 所有值的和与 array 的长度一样。
 *          这时可以对count进行一次变形
 *              原来count中的值代表array中值出现的次数
 *              现在count中的值代表array中的值对应到结果数组中的索引，即count[i+1]=count[i]+count[i+1]
 *              现在 count[i] = j 翻译一下就是: array 数组中的 i 这个值是保存在 result 数组中 j 这个位置的
 *          变形过后: count中最大的索引有着最大的值
 *              count 中 索引最大的对应 array 中值最大的
 *              count 中 值最大的对应 result 中位置（索引）最大的
 *
 *
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
        int[] result = countSort(array);
        System.out.println(Arrays.toString(result));
    }

    /**
     * 计数排序
     * @param array 待排序数组
     */
    public static int[] countSort(int array[]){
        // 1. 获取原数组中最大的值和最小值
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for(int data : array){
            max = Math.max(max, data);
            min = Math.min(min, data);
        }

        // 2. 初始化计数数组, 这时计数数组就不需要开辟无效空间了
        int[] count = new int[(max-min)+1];

        // 3. 将原数组的值转化到计数数组中
        // array 的值与最小值的差值 为 count 的索引
        // array 的值与最小值差值的个数 为 count 的值
        for(int data : array){
            count[data-min]++ ;
        }

        // 4. 对计数数组进行变形
        for(int i=1; i< count.length; i++){
            count[i] = count[i] + count[i-1];
        }

        // 5. 创建结果数组
        int[] result = new int[array.length];

        // 结果数组的索引此时由count提供，这一步就不需要了
        // int index = 0;

        // 6. 将索引和值保存到结果数组中
        for(int i=0; i< array.length; i++){
            result[count[array[i]-min]-1] = array[i];
            //count[array[i]-min]--;
        }
        return result;
    }
}
```

## Scala

### 基础版

```scala
package com.stanlong.scala

/**
 * 计数排序
 * 基础版
 */
object ForDemo {

    def main(args: Array[String]): Unit = {
        var array = Array[Int](3,44,38,5,47,15,36,26,27,2,46,4,19,50,48)
        var result = countSort(array)
        println(result.mkString(","))
    }

    /**
     * 计数排序
     * @param array
     */
    def countSort(array:Array[Int]): Array[Int] ={
        // 1. 取出数组中的最大值
        var max = array.max;

        // 2. 初始化计数数组
        var count = new Array[Int](max+1)

        // 3. 将原数组的值转化到计数数组中
        // array 的值与最小值的差值 为 count 的索引
        // array 的值与最小值差值的个数 为 count 的值
        for(data <- array){
            count(data) = count(data) + 1
        }

        // 4. 创建结果数组
        var result = new Array[Int](array.length)

        // 结果数组索引
        var index = 0;

        // 5. 将计数数组中值不为0的索引保存到结果数组中
        for(i <- 0 until(count.length)){
            while (count(i) != 0){
                result(index) = i
                index = index + 1
                count(i) = count(i) - 1
            }
        }
        result
    }
}
```

### 优化版

```scala
package com.stanlong.scala

/**
 * 计数排序
 * 优化版
 */
object ForDemo {

    def main(args: Array[String]): Unit = {
        var array = Array[Int](3,44,38,5,47,15,36,26,27,2,46,4,19,50,48)
        var result = countSort(array)
        println(result.mkString(","))
    }

    /**
     * 计数排序
     * @param array
     */
    def countSort(array:Array[Int]): Array[Int] ={
        // 1. 取出数组中的最大值
        var max = array.max;
        var min = array.min;

        // 2. 初始化计数数组
        var count = new Array[Int]((max-min)+1)

        // 3. 将原数组的值转化到计数数组中
        // array 的值与最小值的差值 为 count 的索引
        // array 的值与最小值差值的个数 为 count 的值
        for(data <- array){
            count(data-min) = count(data-min) + 1
        }

        // 4. 创建结果数组
        var result = new Array[Int](array.length)

        // 结果数组索引
        var index = 0;

        // 5. 将计数数组中值不为0的索引保存到结果数组中
        for(i <- count.indices){
            while (count(i) != 0){
                result(index) = i+min
                index = index + 1
                count(i) = count(i) - 1
            }
        }
        result
    }
}
```

### 进阶版

```scala
package com.stanlong.scala

/**
 * 计数排序
 * 进阶版
 */
object ForDemo {

    def main(args: Array[String]): Unit = {
        var array = Array[Int](3,44,38,5,47,15,36,26,27,2,46,4,19,50,48)
        var result = countSort(array)
        println(result.mkString(","))
    }

    /**
     * 计数排序
     * @param array
     */
    def countSort(array:Array[Int]): Array[Int] ={
        // 1. 取出数组中的最大值
        val max = array.max;
        val min = array.min;

        // 2. 初始化计数数组
        var count = new Array[Int]((max-min)+1)

        // 3. 将原数组的值转化到计数数组中
        // array 的值与最小值的差值 为 count 的索引
        // array 的值与最小值差值的个数 为 count 的值
        for(data <- array){
            count(data-min) = count(data-min) + 1
        }

        // 4. 对count数组进行变形
        for(i <- 1 until(count.length)){
            count(i) = count(i) + count(i-1)
        }

        // 5. 创建结果数组
        var result = new Array[Int](array.length)

        // 结果数组的索引此时由count提供，这一步就不需要了
        // var index = 0;

        // 5. 将计数数组中值不为0的索引保存到结果数组中
        for(i <- array.indices){
            result(count(array(i)-min)-1) = array(i)
        }
        result
    }
}
```

## Python

### 基础班

### 优化版

### 进阶版

