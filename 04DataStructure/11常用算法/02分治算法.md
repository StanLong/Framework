# 分治算法

分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

**分治算法可以求解的一些经典问题**

- 二分搜索
- 大整数乘法
- 棋盘覆盖
- 合并排序
- 快速排序
- 线性时间选择
- 最接近点对问题
- 循环赛日程表
- 汉诺塔

**分治算法的基本步骤**

分治法在每一层递归上都有三个步骤：

1. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. 合并：将各个子问题的解合并为原问题的解。

**汉诺塔的传说**

汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。

![](https://cdn.jsdelivr.net/gh/StanLong/Framework/04DataStructure/doc/19.gif)

```java
package com.stanlong;

/**
 * 分治算法最佳实践
 * 汉诺塔问题
 * 步骤:
 * 1. 先把最上面的盘从A移到B. 移动过程中会使用到C A->B
 * 2. 把最下面的盘移动到C A-C
 * 3. 把B的所有盘移动到C， 移动过程会使用到A B->C
 */
public class DataStructure {

    public static void main(String[] args) throws Exception {
        haniTower(3, 'A', 'B', 'C');
    }

    /**
     * 汉诺塔问题
     * @param num 盘子的数目
     * @param a 起始盘
     * @param b 辅助盘
     * @param c 目的盘
     */
    public static void haniTower(int num, char a, char b, char c){
        if(num == 1){ // 如果只有一个盘子
            System.out.println("第1个盘从" + a + "->" + c);
        }else{
            // 如果有 num >= 2 的情况， 可以只看成两个盘。 第一个盘是最下面的盘， 第二个盘是上面的所有盘
            // 1. 先把最上面的盘从A移到B. 移动过程中会使用到C
            haniTower(num-1, a, c, b);
            // 2. 把最下面的盘移动到C
            System.out.println("第" + num + "个盘从" + a + "->" + c);
            // 3. 把B的所有盘移动到C， 移动过程会使用到A
            haniTower(num-1, b, a, c);

        }
    }
}
```

```
第1个盘从A->C
第2个盘从A->B
第1个盘从C->B
第3个盘从A->C
第1个盘从B->A
第2个盘从B->C
第1个盘从A->C
```



